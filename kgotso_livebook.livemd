# Kgotso Learning Elixir

## Pattern matching

```elixir
# Pattern matching->It allows you to destructure and match values against patterns, enabling you to extract and manipulate data ..
# in a concise and expressive way
a = 10
b = 20
c = a + b

IO.puts("The sum of #{a} and #{b} is #{c}.")
```

## Understanding a module and a function

```elixir
defmodule Hello do
  # word is a function 
  def word do
    IO.puts("Hello Kgotso")
  end
end

Hello.word()
```

## Passing a string into a function

```elixir
defmodule Hi do
  def word(name) do
    IO.puts("Hello Kgotso #{name}")
  end
end

Hi.word("kgotso")
```

## DATA TYPES

## Atom

```elixir
# Atoms are useful in cases of applications
# The syntax is just a colon before its name ==> :some_name ... 
# ...if a name of an atom has a space, then u put it in double inverted commas ==> :"Some Name"
:error
{:error, reason} = {:error, "invalid command"}
# {} these curly brackets are called turples

# Its important to note LHS is assigned to RHS...
```

```elixir
# .. so  you can just call LHS, and should expect RHS assigned value
reason
```

```elixir

```

## Strings

```elixir
# Strings are created using double colons
"Kgotso"
# We can check the type of the data structure by using i. i is a function that checks data type...
# ... by saying i("Kgotso") on interactive terminal (iex), we get info of a data type i.e datatype, byte size, description and row representation
# Strings are saved as colection of bytes
```

```elixir
name = "Jerry"
# checks if a varibale is a string
is_binary(name)
```

```elixir
# Adding strings 
message = "Hello " <> name
```

```elixir
# We can use the power of pattern matching to extract contents  of the string

# <> this is called a string concentration operator
"M" <> rest = "Mcasino"
# rest here is assigned all th e characters after M
```

```elixir
# you can decode a character  n this simple way 
?a
```

```elixir
# Extracting the code of the character using Patterm Matching
name = "kgotso"

# the variabe first is going to extract the first charter of name. storing the rest of name's charater as binary
<<first, rest::binary>> = name
first
```

```elixir
# check if its code number
first == ?o
```

```elixir
# it returns as string/binary
rest
```

```elixir
# You can specify how many character you want to extract in a string
<<first::binary-size(3), rest::binary>> = name
first
```

## Charlist

```elixir
# Charlist - collection of charaters in a list
# [] - square brackets  to represent collection of characters within a list , represented by integers
chars = 'kgotso'
```

```elixir
# You can add list as well using ++ instead of <> like in strings
'Hello ' ++ chars
```

```elixir
# You can also check data tye using simply:
is_list(chars)
```

## Turple

```elixir
# data is saved continuosly inside a memory
# created with curly brackets
# normally dont use more than 4 elements inside of a turple, rather go for List

{a, b} = {1, 3}
a
```

```elixir
# exampl of a simle applction in server using turple
{:reply, msg, state} = {:reply, "Input not found", ["good", "complete", "no isssues"]}

state
```

## Section

## Procesess

```elixir
# Runs in processes 
# Idenified by PID 
# Inter-ccommunication by Message Passing. Each Process has its Stack & Heap alocation
# Like humans we dont share data, we just communicate using languages 

# check process ID
my_pid = self()
my_pid
```

## Linked List (Singly)

```elixir
# Linked list are not List
# Not a regular array or list
list = ["a", "b", "c"]

# it is important to note that in ELixir Linked List are recursive

# you cant index in Linked list in Elixir

# list{0}  # I get an error
```

```elixir
Enum.at(list, 0)
```

```elixir
# Enum. + Tab ==> shows list og argumnts can each func take . Func Arity. On the Interactive Tool
# h  Enum.at ==>Helper function.  brings documentationo Interation Tool
# Pattern match 
[first, second, third] = list
second
```

```elixir
# You can ignore some couple of elements in a list by using an underscore
[_, _, third] = ["P", "I", "D"]
third
```

```elixir
# you can get the head of the list 
# returns first element
hd(list)
```

```elixir
# can get the rest of the list  and ignore the first elemey
tl(list)
```

```elixir
# Cons operator |
# it is used to Pattern match
# assigning first element to h and rest to t
[h | t] = list
h
```

```elixir
t
```
