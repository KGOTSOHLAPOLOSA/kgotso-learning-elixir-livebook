# Kgotso Learning Elixir

## Pattern matching

```elixir
# Pattern matching->It allows you to destructure and match values against patterns, enabling you to extract and manipulate data ..
# in a concise and expressive way
a = 10
b = 20
c = a + b

IO.puts("The sum of #{a} and #{b} is #{c}.")
```

## Understanding a module and a function

```elixir
defmodule Hello do
  # word is a function 
  def word do
    IO.puts("Hello Kgotso")
  end
end

Hello.word()
```

## Passing a string into a function

```elixir
defmodule Hi do
  def word(name) do
    IO.puts("Hello Kgotso #{name}")
  end
end

Hi.word("kgotso")
```

## DATA TYPES

## Atom

```elixir
# Atoms are useful in cases of applications
# The syntax is just a colon before its name ==> :some_name ... 
# ...if a name of an atom has a space, then u put it in double inverted commas ==> :"Some Name"
:error
{:error, reason} = {:error, "invalid command"}
# {} these curly brackets are called turples

# Its important to note LHS is assigned to RHS...
```

```elixir
# .. so  you can just call LHS, and should expect RHS assigned value
reason
```

```elixir

```

## Strings

```elixir
# Strings are created using double colons
"Kgotso"
# We can check the type of the data structure by using i. i is a function that checks data type...
# ... by saying i("Kgotso") on interactive terminal (iex), we get info of a data type i.e datatype, byte size, description and row representation
# Strings are saved as colection of bytes
```

```elixir
name = "Jerry"
# checks if a varibale is a string
is_binary(name)
```

this is my great string

```elixir
# Adding strings 
message = "Hello " <> name
```

### We can use the power of pattern matching to extract contents  of the string

```elixir
# <> this is called a string concentration operator
"M" <> rest = "Mcasino"
# rest here is assigned all th e characters after M
```

```elixir
# you can decode a character  n this simple way 
?a
```

```elixir
# Extracting the code of the character using Patterm Matching
name = "kgotso"

# the variabe first is going to extract the first charter of name. storing the rest of name's charater as binary
<<first, rest::binary>> = name
first
```

```elixir
# check if its code number
first == ?o
```

```elixir
# it returns as string/binary
rest
```

```elixir
# You can specify how many character you want to extract in a string
<<first::binary-size(3), rest::binary>> = name
first
```

## Charlist

```elixir
# Charlist - collection of charaters in a list
# [] - square brackets  to represent collection of characters within a list , represented by integers
chars = 'kgotso'
```

```elixir
# You can add list as well using ++ instead of <> like in strings
'Hello ' ++ chars
```

```elixir
# You can also check data tye using simply:
is_list(chars)
```

## Turple

```elixir
# data is saved continuosly inside a memory
# created with curly brackets
# normally dont use more than 4 elements inside of a turple, rather go for List

{a, b} = {1, 3}
a
```

```elixir
# exampl of a simle applction in server using turple
{:reply, msg, state} = {:reply, "Input not found", ["good", "complete", "no isssues"]}

state
```

## Procesess

```elixir
# Runs in processes 
# Idenified by PID 
# Inter-ccommunication by Message Passing. Each Process has its Stack & Heap alocation
# Like humans we dont share data, we just communicate using languages 

# check process ID
my_pid = self()
my_pid
```

## Linked List (Singly)

```elixir
# Linked list are not List
# Not a regular array or list
list = ["a", "b", "c"]

# it is important to note that in ELixir Linked List are recursive

# you cant index in Linked list in Elixir

# list{0}  # I get an error
```

```elixir
Enum.at(list, 0)
```

```elixir
# Enum. + Tab ==> shows list og argumnts can each func take . Func Arity. On the Interactive Tool
# h  Enum.at ==>Helper function.  brings documentationo Interation Tool
# Pattern match 
[first, second, third] = list
second
```

```elixir
# You can ignore some couple of elements in a list by using an underscore
[_, _, third] = ["P", "I", "D"]
third
```

```elixir
# you can get the head of the list 
# returns first element
hd(list)
```

```elixir
# can get the rest of the list  and ignore the first elemey
tl(list)
```

```elixir
# Cons operator |
# it is used to Pattern match
# assigning first element to h and rest to t
[h | t] = list
h
```

```elixir
t
```

## Keyword List

```elixir
#
#
# a is a key, 1 is value. A key is actally an atom
data = [a: 1, b: 2]
```

```elixir
# pattern match
[{:a, 1}] = [a: 1]
```

```elixir
# extracting for keyword list
data[:a]
```

## Maps

```elixir
# One of the key thing about mps is that it can be used with different data types
my_map = %{a: 1, b: 2, c: 3}
my_map
```

```elixir
# Pattern match
%{a: first, b: second, c: third} = my_map
first
```

```elixir
# can pattern match  one by one, no need to for the whole map
%{b: second} = my_map
second
```

```elixir
# we can use dot notation to access stuff in a map
my_map.a
```

```elixir
# map created ussing string
map2 = %{"a" => 1, "b" => 2, "c" => 3}
```

```elixir
# exctracting frm a string map
%{"c" => c} = map2
c
```

```elixir
# Uodating a map with strings
map2 = %{map2 | "c" => 4}
```

```elixir
# updating map with Atom 
my_map = %{my_map | c: 4}
```

## Struct

```elixir
# Sturct is defined within a module
# filds in struct are defined in form of keys

defmodule User do
  defstruct username: "", email: "", age: nil
end
```

```elixir
# working with struct is similiar like working with a map
user1 = %User{username: "kgotso", email: "kgotsohlapolosa@gmail.com", age: 21}
```

```elixir
# extracting from a struct
%{username: username} = user1
username
```

```elixir
# Updating in a struct
user1 = %{user1 | age: 29}
```

## Case - Flow Mechanism

```elixir
# Case behave like  switch statements
list = [1, 2, 3]
```

```elixir
case Enum.at(list, 2) do
  1 -> "This is a good sign"
  3 -> "This is alright"
  _ -> "nothing at all"
end
```

```elixir
# Cases can be used with any data structure or type
# this example here is for Struct

defmodule Post do
  defstruct(
    id: nil,
    tittle: "",
    description: "",
    author: ""
  )
end
```

```elixir
# Now fill in contents of your struct
post1 = %Post{id: 1, tittle: "This is the story", author: "Kgotso Hlapolosa"}
```

```elixir
# Now create a case for post1
case post1 do
  %{author: "Kgotso Hlapolosa"} -> "Kgotso saw this"
  %{author: "Thato"} -> "This is thato"
  _ -> "None of the above"
end
```

```elixir
# You can update post1 like any other map
post1 = %{post1 | author: "Blessing"}
```

```elixir
# Update and reevaluate 
# Now create a case for post1
case post1 do
  %{author: "Kgotso Hlapolosa"} -> "Kgotso saw this"
  %{author: "Thato"} -> "This is thato"
  _ -> "None of the above"
end
```

## Cond - Flow Mechanism

```elixir
cond do
  post1.author == "Kgotso Hlapolosa" -> "This is kgotso"
  post1.author == "Thato" -> "this is thato"
  true -> "This is it"
end
```

```elixir
cond do
  hd(list) == 2 -> "Got a one"
  true -> "Head is #{hd(list)}"
end
```

## if/else Flow Mechanism

```elixir
if true do
  "this will work"
else
  "ELse this will work"
end
```

## MIX

Mix -  MIX provides a set of commands and tasks to help you create, manage, and build Elixir projects. It simplifies tasks such as creating a new project, compiling code, running tests, managing dependencies, and more.

<!-- livebook:{"break_markdown":true} -->

When you create a new Elixir project using MIX, it generates several files and folders to organize your project's codebase. Here is a short description of some of the key files and folders that MIX creates:

mix.exs: This is the project configuration file written in Elixir. It contains information about the project, such as its name, version, dependencies, and other settings.

lib/: This folder is where you typically store your project's Elixir source code files. The folder structure inside lib/ mirrors the application structure.

test/: This folder is used to store the test files for your project. Elixir's built-in testing framework, ExUnit, is commonly used to write and run tests in this directory.

config/: This folder contains configuration files for the project. Common files include config.exs, where you can configure various settings for different environments (development, test, production, etc.).

deps/: This folder is automatically created to store the project's dependencies when you fetch them using MIX.

_build/: This folder is created when you compile your project with MIX. It contains the compiled artifacts, such as bytecode and other necessary files, organized by environment.

priv/: This folder is for private files, such as static assets or resources that are used by the application.

assets/ (sometimes included, but depends on the project template): This folder is used for web applications and contains frontend-related assets, such as JavaScript, CSS, and other static files

```elixir
# To create a new project using mix ..
# .. simply type mix new Project_Name
# Then you can open it with code editor by simly getting inside #Project_name then type code . on terminal
```

## Recursion - Tail Recursion - Print Digits

This code below here prints digits in Ascending Stage.

```elixir
defmodule Recursion do
  # This is a base case, incse the input is zero, return zero and exit
  def upto(0), do: 0

  # Receives an input number
  def upto(nums) do
    # it prints the input number
    IO.puts(nums)

    # Here subtract the input number by 1, then go back to the base case and repeat the previous steps
    upto(nums - 1)
  end
end

# Input number is 3. So we expect 3 2 1 0 to be printed
Recursion.upto(3)
```

This code below here prints digits in Ascending Stage

```elixir
defmodule Recursion1 do
  # This is a base case, incse the input is zero, return zero and exit
  def upto(0), do: 0

  # Receives an input number
  def upto(nums) do
    # This function needs to be exhausted. Basically if your inout is 3 ...
    upto(nums - 1)
    # .. it means upto is going subtract 1 from three until it reaches zero ...
    # ...  then when it reaches zero, its gonna print zero then go to IO.puts
    # This statement here does nothing until upto is exhausted, then its gonna print pending task in descending order
    IO.puts(nums)
  end
end

Recursion1.upto(3)
```

## Recursion- Sum degits

```elixir
defmodule Recursion2 do
  # this is a base case 
  def upto(0), do: 0

  # Recursice case statement
  def upto(num) do
    # The function upto has to be exhausted. Remember only the last ouput of the recursion is returned
    num + upto(num - 1)
  end
end

Recursion2.upto(3)
```

## Recursion - Tail Recursion - Sum Digits

We can repeat the same function using Tail Recursion

```elixir
defmodule Recursive3 do
  def upto(0), do: 0

  def upto(num) do
    upto_tail_rec(num)
  end

  # function defination. It accepts num as input. The accumulator is set to default \\ zero
  def upto_tail_rec(num, acc \\ 0)
  # base case cond 
  def upto_tail_rec(0, acc), do: acc

  def upto_tail_rec(num, acc) do
    # recursive call. It will exit when it looks like (0,6). therefore returns 6 
    upto_tail_rec(num - 1, acc + num)
  end
end

Recursive3.upto(3)
```

This Tail Recursive function uses LESS MEMORY.also REUSE THE SAME STACK, meaning there is no exra memoty allocation

## Recursion -Factorial

```elixir
# Remember factorial. 3! = 3*2*1 = 6
defmodule Recursive4 do
  # base case
  def of(1), do: 1
  # recursive func. 
  def of(num), do: num * of(num - 1)
end

Recursive4.of(3)
```

We can do the same but using Tail Recursion

```elixir
defmodule Recursion5 do
  # function defination
  def of_tail_rec(num, acc \\ 1)
  # base case 
  def of_tail_rec(1, acc), do: acc
  def of_tail_rec(num, acc), do: of_tail_rec(num - 1, acc * num)
end

Recursion5.of_tail_rec(3)
```
